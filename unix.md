### 1. 进程间通信(InterProcess Communication, IPC)方式有哪些？

> #### 管道
>
> 管道是 UNIX 系统 IPC 的最古老形式，所有 UNIX 系统都提供此种通信机制。管道有以下两种局限性。
>
> - 半双工，某些系统提供全双工管道，但是为了最佳的可移植性，不应预先假定系统支持全双工管道。
> - 管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用`fork`之后，
>   这个管道就只能在父进程和子进程之间使用了。
>
> 管道是通过调用`pipe`函数创建的。
>
> ```c
> #include <unistd.h>
>
> // 若成功，返回 0，若出错，返回 -1
> int pipe(int fd[2]);
> ```
>
> 单进程的管道几乎没有任何用户。通常，进程会先调用`pipe`，接着调用`fork`，从而创建从父进程到子进程
> 的 IPC 通道，反之亦然。
> 当管道的一端被关闭后，下列两条规则起作用：
>
> - 当读（read）一个写端已被关闭的管道时，在所有数据都被读取后，read 返回 0，表示文件结束。
> - 当写（write）一个读端已被关闭的管道，则产生信号 SIGPIPE。
>
> `popen` 和 `pclose`
>
> ```c
> #include <stdio.h>
>
> // 若成功，返回文件指针；若出错，返回 NULL
> FILE *popen(const char *cmdstring, const char *type);
>
> // 若成功，返回 cmdstring 的终止状态；若出错，返回 -1
> int pclose(FILE *fp);
> ```
>
> 函数`popen`先执行`fork`，然后调用`exec`执行`cmdstring`，并且返回一个标准 I/O 文件指针。
> 如果`type`是`"r"`，则文件指针连接到`cmdstring`的标准输出。
> 如果`type`是`"w"`，则文件指针连接到`cmdstring`的标准输入。

### 2. 进程终止的方式

> 有 8 种方式可以使进程终止，其中 5 种为正常终止：
>
> - 从`main`返回；
> - 调用`exit`；
> - 调用`_exit`或`_Exit`；
> - 最后一个线程从其启动例程返回；
> - 从最后一个线程调用`pthread_exit`。
>
> 异常终止方式有 3 种：
>
> - 调用`abort`；
> - 接到一个信号；
> - 最后一个线程对取消请求做出响应。
